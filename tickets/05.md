# Билет 5
## О чём билет
Многофайловая разработка. Заголовочные файлы, препроцессор, include guard.

### Многофайловая разработка
Кратко: есть несколько `.cpp` файлов, по которым распределён код программы. **Компиляция** происходит 
независимо для каждого файла с исходным кодом, однако command line interface у компилятора позволяет 
указывать сразу несколько входящих файлов (единиц трансляции). Поскольку код в одном файле может 
ссылаться на код в другом файле, для разрешения подобных зависимостей нужен дополнительный 
шаг - **линковка**.

### Единица трансляции
Каждый входной файл называется единицей трансляции.

### Объектный файл
Объектный файл, получающийся после компиляции входного `.cpp`, содержит информацию о символах (symbol), 
а именно о ссылках на символы (references) и об их реальных определениях (definitions).

### Символ
Каждый символ соответствует: функции, глобальной переменной, статической переменной. Предназначение 
символов в том, чтобы после линковки каждой ссылке на символ соответствовало одно и только одно 
определение данного символа (в противном случае линковщик кинет ошибку).

### Линковка
Линковка осуществляет соответствие между импортируемыми и экспортируемыми символами. Для успешной линковки 
каждому импортируемому символу должен соответствовать ровно один экспортируемый.

### Заголовочные файлы
Это файлы, в которых перечислены файлы проекта, исходный код которых потребуется в проекте.
Чтобы включить файл в зависимость, можно воспользоваться директивой `#include "path/to/the/file.cpp"`.
Такие заголовочные файлы позволяют укомплектовать все зависимости в один файл, вместо прописывания их 
в каждом `.cpp` файле. Обычно расширения файлов заголовков такие: `.hpp`, `.h++`, `.hh`, `.h`.

### Препроцессор
Заголовочные файлы включаются в текст программы с помощью директивы препроцессора `#include "path/to/header_file.hpp"`.
Программа, обрабатывающая эти директивы, называется препроцессором (в современных компиляторах препроцессор
обычно является частью компилятора).

### One Definition Rule (ODR)
В любой единице трансляции допустимо только одно определение любой переменной, функции, типа класса, типа
перечисления, шаблона или (начиная с C++20) концепта.

### Include guard
Для того, чтобы не нарушать ORD при использовании заголовков, обычно почти во всех заголовках указывается
следующая последовательность команд препроцессора, гарантирующая, что соответствующий заголовок появится
в трансляционной единице не более одного раза:
```cpp
#ifndef MY_HEADER_HPP // 'ifndef' читается как 'if not defined', 
                      // то есть если данный флаг не объявлен, препроцессор спускается в if блок
#define MY_HEADER_HPP // Объявляем флаг 'MY_HEADER_HPP
/* header code */
/* some includes or declarations */
#endif // MY_HEADER_HPP - выходим из блока, в который зашли, потому что флаг MY_HEADER_HPP не был объявлен. Теперь он объявлен.
```
Такой приём называется 'использованием include guard'.

