# Билет 8
## О чём билет
STL. Инициализация с помощью `{}`, initializer_list, range-based for. auto.

### STL
Standard Template Library - набор шаблонов классов и функций, реализующих полезную в повседневной работе функциональность. Доступ к ним осуществляется
через подключение определённых заголовочных файлов. Также, STL предоставляет итераторы - объекты, позволяющие осуществлять удобный перебор элементов
в контейнерах. Шаблоны STL хранятся в динамической библиотеке.

### Инициализация с помощью `{}` (uniform initialization)
Начиная с C++11, можно использовать фигурные скобки для инициализации вместо обычных при указании параметров конструктора.
Это образует отдельный тип инициализации - list initialization (uniform initialization).

Примеры:
```cpp
int x {42};           // Инициализация int со значением 42
double y {3.14};      // Инициализация double со значением 3.14
char c {'a'};
bool b {true};
std::string s {"hello"}; // Инициализация строки со значением "hello"
std::vector<int> v {1, 2, 3}; // Инициализация вектора со значениями 1, 2 и 3

class Foo {
public:
    Foo(int n, double d) { /* реализация конструктора */ }
};

Foo foo {42, 3.14};    // Инициализация объекта с аргументами 42 и 3.14
int arr[] {1, 2, 3};  // Инициализация массива со значениями 1, 2 и 3
std::pair<int, std::string> p {42, "hello"}; // Инициализация пары значений 42 и "hello"
```

Одно из главных преимуществ list initialization в том, что оно помогает предотвратить 'сужающее' конвертирование значений.
То есть, например, строчка `int i {3.14};` заставит компилятор выдать ошибку о том, что тут происходит потеря информации при
конвертации числа с плавающей точкой в целочисленный тип.

В целом, list initialization предоставляет более устойчивый и безопасный синтаксис для инициализации объектов в C++.

### `std::initializer_list`
Простейший контейнер в STL, позволяющий хранить внутри себя различные типы и итерироваться по ним. Данный контейнер 
был разработан для инициализации объектов с фигурными скобками, позволяя функциям и конструкторам принимать
переменное число аргументов одного и того же типа, без необходимости указывать количество аргументов заранее.

Пример:
```cpp
#include <initializer_list>
#include <iostream>

class Foo {
public:
    Foo(std::initializer_list<int> values) {
        for (auto v : values) {
            std::cout << v << " ";
        }
        std::cout << std::endl;
    }
};

void print(std::initializer_list<int> values) {
    for (auto v : values) {
        std::cout << v << " ";
    }
    std::cout << std::endl;
}

int main() {
    Foo foo {1, 2, 3}; // Инициализация объекта Foo со значениями 1, 2 и 3
    print({1, 2, 3}); // Вызывает функцию print со значениями 1, 2 и 3
    return 0;
}
```

### Range-based for (`for(<type> <variable> : <iterable container>)`)
Более читаемый эквивалент традиционному for-циклу, итерирующемуся по контейнеру. Обращается конкретно к данным, а не к
итераторам

Пример:
```cpp
#include <iostream>
#include <vector>

int main(int argc, char* argv[]) {
  std::vector<int> a {1, 2, 3};
  for (auto value : a) { // auto автоматически подставляет тип переменной value, в данном случае int
    std::cout << value << std::endl;
  }
  /* Output:
   * 1
   * 2
   * 3
   */
   return 0;
}
```

К переменной итерирования можно применять модификаторы, например:
```cpp
for (const auto& value : a) {
  /* do something with value */
}
```

### `auto`
`auto` позволяет не указывать тип переменной при условии, что он может быть выведен из контекста.

Пример:
```cpp
std::vector<int> a {1, 2, 3};
for (auto value : a) { // Тип очевидно выводится в int
  /* ... */
}
```
