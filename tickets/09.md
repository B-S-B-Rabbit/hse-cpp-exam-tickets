# Билет 9
## О чём билет
STL. Инвалидация итераторов. Работа со временем. ГПСЧ.

### STL
Standard Template Library - набор шаблонов классов и функций, реализующих полезную в повседневной работе функциональность. Доступ к ним осуществляется
через подключение определённых заголовочных файлов. Также, STL предоставляет итераторы - объекты, позволяющие осуществлять удобный перебор элементов
в контейнерах. Шаблоны STL хранятся в динамической библиотеке.

### Инвалидация итераторов
Простым языком: это событие, когда итератор перестаёт указывать туда, куда он должен указывать, то есть итератор становится невалидным. Такое происходит с разными контейнерами:
- `std::vector`: при добавлении элемента сверх текущей вместимости (`capacity`) массив данных реаллоцируется, из-за чего
  итератор на прошлое место перестаёт быть валидным. При удалении элемента - инвалидация итератора удаляемого элемента и
  всех после него.
- `std::deque`: при удалении первого и последнего элементов - инвалидация только соответствующих итераторов. При добавлении
  или удалении элементов в середине - инвалидация всех итераторов.
- `std::queue`: так как `std::queue` - это контейнер адаптер, реализующий свою структуру данных с использованием другого
  контейнера (обычно `std::deque` или `std::list`), то инвалидация зависит от подлежащей структуры.

Как правило, итераторы автоматически инвалидируются, и при следующей попытке использования недействительного итератора
будет выброшено исключение `std::out_of_range`.

### Работа со временем
STL предоставляет примитивы для работы со временем в заголовке `<chrono>`. К ним относятся:

Часы `std::chrono::*_clock` (вместо звездочки разные типы)
  - `std::chrono::steady_clock` - это монотонные часы, **неподверженные** изменениям системных часов. Они полезны для
    измерения прошедшего времени между двумя точками в программе.
    
    Пример:
    ```cpp
    #include <iostream>
    #include <chrono>

    void myFunction() {
        // Симулируем работу (такой код на деле соптимизируется до NOOP при флаге оптимизации -O3)
        for (int i = 0; i < 100000000; ++i) {}
    }

    int main() {
        // Берём начальный замер времени, 'now()' вернёт 'std::chrono::time_point<std::chrono::steady_clock>'
        auto start_time = std::chrono::steady_clock::now();

        // Вызываем функцию, производительность которой хотим замерить
        myFunction();
        
        // Берём конечный замер времени, 'now()' вернёт 'std::chrono::time_point<std::chrono::steady_clock>'
        auto end_time = std::chrono::steady_clock::now();
        
        // Высчитываем 'продолжительность' периода в миллисекундах
        auto duration_ms = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);
        
        std::cout << "myFunction took " << duration_ms.count() << " milliseconds to execute." << std::endl;
        return 0;
    }
    ```
  - `std::chrono::system_clock` - эти часы представляют общесистемные часы реального времени. Это часы, которые обычно 
    используются для измерения календарного времени. Они не гарантируют монотонности, но годятся в качестве timestamp для логирования.
  - `std::chrono::high_resolution_clock` - эти часы идентичны `std::chrono::steady_clock`, но обеспечивают максимальное
    возможное разрешение, доступное в системе.

Временная длительность `std::chrono::duration` - определяется как число отсчётов заданной периодичности.

Точка во времени `std::chrono::time_point` - представляет из себя число отсчетов некоторой периодичности, прошедших
с момента начала отсчёта в каких-то выбранных часах, например:
```cpp
// Точка во времени, отсчитываемом часами 'steady_clock' и равная текущему монотонному времени в моменте
std::chrono::time_point<std::chrono::steady_clock> moment = std::chrono::steady_clock::now();
```

### ГПСЧ (Генерация псевдослучайных чисел)
В STL заголовке `<random>` есть два основных типа объектов - это движки (engine) и распределения (distributions).

**Движки** - это генераторы случайных чисел с квази-однородным распределением, то есть распределением, имеющим
некоторую степень равномерности, но не являющимся абсолютно равномерным в силу определённых ограничений или ограничений
в процессе генерации. В контексте генераторов случайных чисел это значит, что генерируемые случайные числа похожи на
случайные, но не совсем такие же, как если бы они были сгенерированы абсолютно равномерным распределением.

Виды движков в STL:
- `std::mersenne_twister_engine` - шаблонный класс, реализующий алгоритм ["Вихря Мерсенна"](https://en.wikipedia.org/wiki/Mersenne_Twister)
- `std::linear_congruential_engine` шаблонный класс, реализующий ["Линейный конгруэнтный метод"](https://en.wikipedia.org/wiki/Linear_congruential_generator)
- `std::subtract_with_carry_engine` шаблонный класс, реализующий ["Subtract-with-carry"](https://en.wikipedia.org/wiki/Subtract_with_carry)

Пример использования `std::mt19937`, 32-битной реализации движка Мерсенна:
```cpp
#include <iostream>
#include <random>

int main() {
    // Создаём движок
    std::mt19937 mt_engine;

    // Устанавливаем состояние движка через seed
    mt_engine.seed(0);

    int random_int = mt_engine();
    std::cout << "Random integer: " << random_int << std::endl;
    return 0;
}
```
Доступна также 64-битная реализация - `std::mt19937_64`.

Способы инициализации движка:
- Используя оператор `()` объекта `std::random_device`, который является источником случайности на уровне железа.
  ```cpp
  std::random_device rd;
  std::mt19937 mt_engine(rd());
  ```
- Используя фиксированный seed:
  ```cpp
  std::mt19937 mt_engine(12345);
  ```
- Используя время:
  ```cpp
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  std::mt19937 mt_engine(seed);
  ```
- Используя комбинации вышеизложенных способов, например, XOR-я их значения.

**Распределения** - это обёртки, превращающие выходные квази-случайные числа движков в распределение случайных чисел
с желаемыми характеристиками (тип распределения, минимальное/максимальное число, среднее значение, стандартное отклонение,
функция плотности и так далее).

Некоторые виды распределений в STL:
- `std::uniform_int_distribution`: генерирует равномерно распределённые целые числа в рамках указанного диапазона.
- `std::uniform_real_distribution`: генерирует равномерно распределённые числа с плавающей точкой в рамках указанного диапазона.
- `std::bernoulli_distribution`: генерирует булевы значения с указанной вероятностью появления положительного (`true`).
- `std::binomial_distribution`: генерирует число успехов в фиксированном числе независимых опытов Бернулли с заданной частотой успеха в рамках одного опыта.
- `std::geometric_distribution`: генерирует число независимых опытов Бернулли, которые необходимо провести, чтобы получить 1 успех с заданной вероятностью успеха в рамках отдельного опыта.

Пример использования `std::uniform_int_distribution`:
```cpp
#include <iostream>
#include <random>

int main() {
    std::mt19937 mt_engine(0);
    // Создаём равномерное целочисленное распределение от 0 до 99
    std::uniform_int_distribution<int> dist(0, 99);

    for (int i = 0; i < 10; ++i) {
      // Получаем следующее число согласно распределению, использующему 32-битный движок Мерсенна
      int random_int = dist(mt_engine);
      std::cout << "Random integer: " << random_int << std::endl;
    }
    return 0;
}
```
