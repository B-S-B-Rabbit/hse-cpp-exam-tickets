# Билет 10
## О чём билет
Контейнеры. deque, stack, queue, forward_list, list, pair, unordered_map

### Контейнеры
Контейнеры – это классы или наборы методов, которые определены в заголовочных файлах и представляют собой структуры данных
с соответствующими методами и характеристиками. Наборы методов же предоставляют полезную функциональность,
связанную с алгоритмами и работой со структурами данных.

### `std::deque`
Двусвязная очередь, предоставляющая похожий на динамический массив интерфейс с эффективной вставкой и удалением элемента
с обоих концов.

Внутренне устроена как последовательность массивов фиксированного размера, часто называемых буферами
(buffer) или блоками (blocks). Каждый из блоков может содержать определённое число элементов (обычно между 8-ью и 64-мя).
Блоки аллоцируются на куче, а указатели на блоки хранятся в служебном "map" массиве, который тоже аллоцируется на куче.
Массив "map" поддерживает блоки вместе с их размерами, позволяя эффективно индексироваться и итерироваться по элементам
двусвязной очереди.

Когда вы вносите новый элемент в начало или конце двусвязной очереди, ей может понадобиться аллоцировать или деаллоцировать
один или более блоков и переместить существующие элементы между блоками, чтобы поддерживать последовательную расстановку в памяти.

В целом, `std::deque` представляет гибкую и эффективную структуру данных для хранения и манипулирования последовательностью элементов.
Со сложностью `O(1)` для удаления и вставки на концах и `O(n)` для доступа к случайному индексу и итерирование.

Пример:
```cpp
#include <iostream>
#include <deque>

int main() {
    std::deque<int> myDeque;

    myDeque.push_front(1);
    myDeque.push_back(2);
    myDeque.push_back(3);
    myDeque.push_front(0);

    for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 0 1 2 3

    myDeque.pop_front();
    myDeque.pop_back();

    for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 1 2
    return 0;
}
```

### `std::stack`
"Cтек" (stack) представляет собой адаптер контейнера, который использует другой контейнер в качестве внутренней реализации, и предоставляет интерфейс LIFO (Last-In-First-Out, Последним-Зашёл-Первым-Вышел) для вставки и извлечения элементов.

`std::stack` может быть создан на основе разных контейнеров, таких как `std::deque`, `std::list`, `std::vector` и другие, но наиболее распространённым выбором является `std::deque`, он же используется по умолчанию, но можно указать желаемый контейнер при инициализации. Это связано с тем, что `std::deque` предоставляет константное время доступа к началу и концу контейнера, а также эффективные операции вставки и удаления элементов на обоих концах, что важно для реализации стека.

При использовании `std::stack` вы можете добавлять элементы в стек с помощью функции `push()`, а извлекать с помощью функции `pop()`. Кроме того, вы можете получить значение верхнего элемента стека с помощью функции `top()`, а также проверить, пуст ли стек, с помощью функции `empty()`. Всё эти команды имеют сложность `O(1)`.

Пример:
```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> myStack;
    std::stack<int, std::list<int>> stackUsingList;
    std::stack<int, std::vector<int>> stackUsingVector;

    myStack.push(1);
    myStack.push(2);
    myStack.push(3);

    while (!myStack.empty()) {
        std::cout << myStack.top() << " ";
        myStack.pop();
    }
    // Output: 3 2 1
    return 0;
}
```

### `std::queue`
`std::queue` - это контейнерный класс, который представляет собой очередь, в которую можно вставлять элементы только в конец и удалять элементы только из начала.

По умолчанию `std::queue` использует адаптер контейнера `std::deque` для хранения элементов, но также можно использовать адаптеры контейнеров `std::list` и `std::vector`.

Для добавления элемента в очередь используется метод `push()`, а для удаления - метод `pop()`. Для доступа к элементу в начале очереди используется метод `front()`, а для проверки, пуста ли очередь, можно использовать метод `empty()`.

Для итерирования по очереди можно использовать стандартные алгоритмы итерирования, такие как `std::for_each()` или `std::transform()`, или использовать итераторы, возвращаемые методами `begin()` и `end()`.

В отличие от `std::vector` и `std::deque`, `std::queue` не предоставляет доступа к элементам по индексу, поскольку доступ к элементу должен быть возможен только для первого элемента очереди.

Сложность операций `push()`, `pop()`, `front()`, `empty()` - `O(1)`.

Пример:
```cpp
#include <iostream>
#include <queue>

int main() {
    std::queue<int> myQueue;

    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    while (!myQueue.empty()) {
        std::cout << myQueue.front() << " ";
        myQueue.pop();
    }
    // Output: 1 2 3
    return 0;
}
```

### `std::forward_list`
`std::forward_list` является контейнером, который представляет собой односвязный список.

Он отличается от других контейнеров, таких как `std::list`, тем, что каждый элемент списка ссылается только на следующий элемент. 
Это делает его более эффективным по памяти и производительности, но ограничивает возможности обхода списка в обратном направлении.

Каждый элемент списка представляется структурой, содержащей значение и указатель на следующий элемент списка.
Первый элемент списка хранится в специальной структуре, называемой головой списка.

Основные операции, поддерживаемые `std::forward_list`, включают вставку и удаление элементов в начало списка, обход элементов списка, поиск элементов в списке и сортировку элементов списка.

Обычно `std::forward_list` используется в тех случаях, когда не требуется обратный доступ к элементам списка и важна оптимизация памяти.

Time complexities:
- `begin()`, `end()`, `cbegin()`, `cend()`: `O(1)`
- `empty()`, `max_size()`: `O(1)`
- `front()`: `O(1)`
- `push_front(const T& value)`, `emplace_front(Args&&... args)`: `O(1)`
- `pop_front()`: `O(1)`
- `clear()`: `O(N)`
- `insert_after(const_iterator pos, const T& value)`, `emplace_after(const_iterator pos, Args&&... args)`: `O(1)`
- `erase_after(const_iterator pos)`: `O(1)`
- `erase_after(const_iterator first, const_iterator last)`: `O(N)`
- `resize(size_type count)`: `O(count)`
- `swap(forward_list& other)`: `O(1)`
- `remove(const T& value)`: `O(N)`
- `remove_if(UnaryPredicate p)`: `O(N)`
- `unique()`: `O(N)`
- `merge(forward_list& other)`: `O(N)`
- `sort()`: `O(N log N)`
- `reverse()`: `O(N)`

Пример:
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> myForwardList;

    myForwardList.push_front(1);
    myForwardList.push_front(2);
    myForwardList.push_front(3);

    for (auto it = myForwardList.begin(); it != myForwardList.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 3 2 1

    myForwardList.pop_front();
    myForwardList.push_front(4);

    for (auto it = myForwardList.begin(); it != myForwardList.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 4 2 1
    return 0;
}
```

### `std::list`
Двусвязный список. Элементы не хранятся в памяти непрерывно. 
Но каждый элемент хранит указатель на следующий и предыдущий элементы. 
Итераторы не поддерживают произвольную арифметику, только ++ и --.

Может быть использован вместо `std::vector`, если вставка или удаление элементов происходит часто в произвольных позициях.

Особенностью `std::list` является то, что он не обеспечивает доступ к элементам по случайному индексу. Вместо этого доступ к элементам осуществляется путем итерирования по списку. Это означает, что время доступа к элементам зависит от их позиции в списке и может быть `O(n)` в худшем случае.

Список может быть создан пустым или заполненным элементами. Для вставки элементов в список можно использовать методы `push_front` и `push_back`, которые вставляют элементы в начало и конец списка соответственно. Для удаления элементов из списка используются методы `pop_front` и `pop_back`, которые удаляют первый и последний элементы списка.

Один из наиболее важных методов `std::list` - это метод `insert`. Он позволяет вставлять элементы в любое место списка. Метод `insert` имеет несколько перегрузок, которые позволяют вставлять элементы в различные позиции списка. Например, `insert(pos, value)` вставляет элемент `value` перед элементом, на который указывает `pos`.

`std::list` также поддерживает методы `erase`, `clear`, `size`, `empty` и `swap`. Метод `erase` удаляет элементы из списка, метод `clear` очищает список, метод `size` возвращает количество элементов в списке, метод `empty` проверяет, является ли список пустым, а метод `swap` позволяет поменять местами содержимое двух списков за `O(1)`.

Time complexities:
- `begin()`, `end()`: `O(1)`
- `empty()`: `O(1)`
- `size()`: `O(1)` (с C++11)
- `clear()`: `O(N)`
- `swap()`: `O(1)`
- `push_front()`, `pop_front()`, `front()`: `O(1)`
- `push_back()`, `pop_back()`, `back()`: `O(1)`
- `insert(const_iterator pos, const T& value)`: `O(1)`

Пример:
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> mylist;

    mylist.push_back(1);
    mylist.push_back(2);
    mylist.push_back(3);
    mylist.push_front(0);

    for (auto it = mylist.begin(); it != mylist.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 0 1 2 3

    mylist.pop_front();
    mylist.pop_back();

    for (auto it = mylist.begin(); it != mylist.end(); ++it) {
        std::cout << *it << " ";
    }
    // Output: 1 2
    return 0;
}
```

### `std::pair`
`std::pair` - шаблонный контейнер, который просто напросто позволяет хранить два элемента разного
типа.

Пример:
```cpp
#include <utility>
#include <iostream>

int main(int argc, char* argv[]) {
  std::pair<int, std::string> a { 2, "Hello"};
  std::cout << a.first << ' ' << a.second << std::endl;
  return 0;
}
```

### `std::unordered_map`
`std::unordered_map` является реализацией хеш-таблицы в STL. Хеш-таблица - это структура данных, которая позволяет быстро и эффективно выполнять операции поиска, вставки и удаления элементов по ключу. В `std::unordered_map` элементы хранятся в виде пар ключ-значение.

Особенностью `std::unordered_map` является то, что порядок элементов не определен. Это означает, что при итерировании по элементам, они могут быть получены в произвольном порядке. Также следует учитывать, что размер хеш-таблицы может изменяться во время ее использования, в зависимости от количества элементов и заданной загрузки.

`std::unordered_map` поддерживает операции вставки, удаления и поиска элементов за `O(1)` в среднем случае. Однако, в худшем случае время выполнения операций может достигать `O(n)`, если все элементы хеш-таблицы находятся в одной ячейке (bucket).

Кроме того, `std::unordered_map` поддерживает методы `size`, `empty`, `clear` и `swap`. Метод `size` возвращает количество элементов в хеш-таблице, метод `empty` проверяет, является ли хеш-таблица пустой, метод `clear` очищает содержимое хеш-таблицы, а метод `swap` позволяет поменять местами содержимое двух хеш-таблиц.

Time complexities:
- `size()`, `empty()`, `swap(unordered_map& other)`: `O(1)`
- `begin()`, `end()`: `O(1)`
- `insert(const value_type& value)`: `O(1)` или `O(N)` в худшем случае
- `operator[](const Key& key)`: `O(1)` или `O(N)` в худшем случае
- `count(const Key& key)`: `O(1)` или `O(N)` в худшем случае. Вернёт 1 или 0 для `std::unordered_map`.
- `find(const Key& key)`: `O(1)` или `O(N)` в худшем случае. Вернёт итератор на элемент, либо `end()` итератор.
- `contains(const Key& key)`: `O(1)` или `O(N)` в худшем случае. Вернёт `true`/`false`. Начиная с C++20.

Пример:
```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<std::string, int> mymap = {
        {"apple", 1},
        {"banana", 2},
        {"orange", 3}
    };

    mymap.insert({"grape", 4});

    std::cout << "mymap contains:";
    for (auto& x : mymap) {
        std::cout << " {" << x.first << ":" << x.second << "}";
    }
    std::cout << std::endl;
    // Output: mymap contains: {orange:3} {banana:2} {grape:4} {apple:1}

    mymap.erase("orange");

    std::cout << "mymap contains:";
    for (auto& x : mymap) {
        std::cout << " {" << x.first << ":" << x.second << "}";
    }
    std::cout << std::endl;
    // Output: mymap contains: {banana:2} {grape:4} {apple:1}
    return 0;
}
```
